import os
import math
import pyzipper
import tempfile
import numpy as np
from PIL import Image as PILImage
from flask import Flask, request, jsonify
from keras.preprocessing import image
from keras.applications.vgg16 import VGG16, preprocess_input
from keras.models import Model

from pinecone import Pinecone, ServerlessSpec
from StoreVectors import StoreVectors

class DetectMalware:
    def __init__(self,df):
        self.df = df
        
    # Function to convert binary to image
    def determine_width(self,pixel_file_size):
        # Define width based on the pixel file size
        if pixel_file_size <= 10:
            return 32
        elif 10 < pixel_file_size <= 30:
            return 64
        elif 30 < pixel_file_size <= 60:
            return 128
        elif 60 < pixel_file_size <= 100:
            return 256
        elif 100 < pixel_file_size <= 200:
            return 384
        elif 200 < pixel_file_size <= 1000:
            return 512
        elif 1000 < pixel_file_size <= 1500:
            return 1024
        else:
            return 2048 

    def convert_to_image(self,binary_content):
        try:
            pixel_stream = np.frombuffer(binary_content, dtype=np.uint8)

            target_width = self.determine_width(len(pixel_stream))
            target_height = int(np.ceil(len(pixel_stream) / target_width))

            reshaped_image = np.resize(pixel_stream, (target_height, target_width))
            img = PILImage.fromarray(reshaped_image)
            img_resized = img.resize((224, 244), PILImage.BILINEAR)

            return img_resized
        except Exception as e:
            print("An error occurred:", str(e))
            return None



    def search_malware(self,search_image):
        data_folder = ""
        # Search for nearest vectors
        pc = Pinecone(api_key='13fadf20-cd84-43e0-bda3-609c6eca3183')

        # Check if the index exists
        index_name = 'vectors-ransomwares-index'
        if index_name not in pc.list_indexes().names():
            print(f'Index {index_name} is not exists')

        api_key = '13fadf20-cd84-43e0-bda3-609c6eca3183'
        
        indexer = StoreVectors(data_folder, index_name, api_key)

        model = indexer.get_extract_model()
        search_vector = indexer.extract_vector(model,search_image)
        
        # Check if the index exists
        index_name = 'vectors-ransomwares-index-full'
        if index_name not in pc.list_indexes().names():
            print(f'Index {index_name} is not exists')

        # Query Pinecone for nearest vectors
        K = 16
        index = pc.Index(index_name)
        # Perform similarity search
        results = index.query(namespace = "ns2",vector=search_vector.tolist(), top_k=K,include_values= True)

        # Extract the matches
        matches = results['matches']  # Assuming the matches are in the first list

        # Extract the nearest image paths and distances
        nearest_image_paths = [match['id'] for match in matches]
        nearest_distances = [match['score'] for match in matches]

            #Check if the index exists
        index_name_nonmalwares = 'vectors-nonmalwares-index-full'
        if index_name_nonmalwares not in pc.list_indexes().names():
            print(f'Index {index_name_nonmalwares} is not exists')
        
        # Query Pinecone for nearest vectors
        index_nonmalwares = pc.Index(index_name_nonmalwares)
        # Perform similarity search
        results_nonmalwares = index_nonmalwares.query(namespace = "ns2",vector=search_vector.tolist(), top_k=K,include_values= True)

        # Extract the matches
        matches_nonmalwares = results_nonmalwares['matches']  # Assuming the matches are in the first list

        # Extract the nearest image paths and distances
        nearest_image_paths_nonmalwares = [match['id'] for match in matches_nonmalwares]
        nearest_distances_nonmalwares = [match['score'] for match in matches_nonmalwares]

        # Tính trung bình của distances
        avg_distance_ransomwares = np.mean(nearest_distances)
        avg_distance_nonmalwares = np.mean(nearest_distances_nonmalwares)


        # prediction_label = ""
        # if avg_distance_nonmalwares > avg_distance_ransomwares:
        #     prediction_label = "Your file is likely non-malware."
        # elif avg_distance_ransomwares > avg_distance_nonmalwares:
        #     prediction_label = "Your file is likely ransomware."
        # else:
        #     prediction_label = "Unable to determine the type of file."
        prediction_label = ""
        if avg_distance_nonmalwares > avg_distance_ransomwares:
            prediction_label = "non-malware."
        elif avg_distance_ransomwares > avg_distance_nonmalwares:
            prediction_label = "ransomware."
        else:
            prediction_label = "Unable to determine the type of file."

        return {
            "nearest_image_paths": nearest_image_paths,
            "nearest_distances": nearest_distances,
            "nearest_image_paths_nonmalwares": nearest_image_paths_nonmalwares,
            "nearest_distances_nonmalwares": nearest_distances_nonmalwares,
            "avg_distance_ransomwares": avg_distance_ransomwares,
            "avg_distance_nonmalwares": avg_distance_nonmalwares,
            "prediction_label": prediction_label
        }
    
    def extract_zip_to_image(self,file_name,password):
        # folder_path = "files_zip"
        # password = b"infected"  # Convert password to bytes
        image_output_dir = "dataset"

        images = []
        # for file_name in os.listdir(folder_path,password):
        if file_name.endswith(".zip") or file_name.endswith((".rar")):
            file_path = os.path.join(file_name)
            with tempfile.TemporaryDirectory(prefix="temp_", dir=".") as temp_dir:
                try:
                    # Extract zip file to temporary directory
                    with pyzipper.AESZipFile(file_path, 'r') as zip_ref:
                        zip_ref.extractall(temp_dir, pwd=password)

                    # Convert extracted files to binary and then to images
                    for extracted_file in os.listdir(temp_dir):
                        extracted_file_path = os.path.join(temp_dir, extracted_file)
                        if os.path.isfile(extracted_file_path):
                            # Read binary content
                            with open(extracted_file_path, 'rb') as f:
                                binary_content = f.read()
                            
                            # Convert binary content to image
                            img = self.convert_to_image(binary_content)
                            
                            # Store the image along with its file name
                            images.append((extracted_file, img))

                except Exception as e:
                    print(f"An error occurred while processing file: {extracted_file_path}")
                    print(f"Error details: {e}")

        # Save images to disk
        for file_name, img in images:
            image_path = os.path.join(image_output_dir,"data_test", os.path.splitext(file_name)[0] + '.png')
            if not img:
                return None
            else:
                img.save(image_path)
                return image_path