import os,math,pyzipper,tempfile
import tkinter as tk
from tkinter import filedialog
import numpy as np
from PIL import Image as PILImage
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import VGG16, preprocess_input
from tensorflow.keras.models import  Model
import matplotlib.pyplot as plt
from pinecone import Pinecone, ServerlessSpec
from StoreVectors import StoreVectors
from tkinter import simpledialog
from tkinter import*
    
def extract_zip_to_image(file_name,password):
    # folder_path = "files_zip"
    # password = b"infected"  # Convert password to bytes
    image_output_dir = "dataset"

    images = []
    # for file_name in os.listdir(folder_path,password):
    if file_name.endswith(".zip"):
        file_path = os.path.join(file_name)
        with tempfile.TemporaryDirectory(prefix="temp_", dir=".") as temp_dir:
            try:
                # Extract zip file to temporary directory
                with pyzipper.AESZipFile(file_path, 'r') as zip_ref:
                    zip_ref.extractall(temp_dir, pwd=password)

                # Convert extracted files to binary and then to images
                for extracted_file in os.listdir(temp_dir):
                    extracted_file_path = os.path.join(temp_dir, extracted_file)
                    if os.path.isfile(extracted_file_path):
                        # Read binary content
                        with open(extracted_file_path, 'rb') as f:
                            binary_content = f.read()
                        
                        # Convert binary content to image
                        img = convert_to_image(binary_content)
                        
                        # Store the image along with its file name
                        images.append((extracted_file, img))

            except Exception as e:
                print(f"An error occurred while processing file: {extracted_file_path}")
                print(f"Error details: {e}")

    # Save images to disk
    for file_name, img in images:
        image_path = os.path.join(image_output_dir, os.path.splitext(file_name)[0] + '.png')
        print(image_path)
        img.save(image_path)
        return image_path

# Function to convert binary to image
def determine_width(pixel_file_size):
       # Define width based on the pixel file size
    if pixel_file_size <= 10:
        return 32
    elif 10 < pixel_file_size <= 30:
        return 64
    elif 30 < pixel_file_size <= 60:
        return 128
    elif 60 < pixel_file_size <= 100:
        return 256
    elif 100 < pixel_file_size <= 200:
        return 384
    elif 200 < pixel_file_size <= 1000:
        return 512
    elif 1000 < pixel_file_size <= 1500:
        return 1024
    else:
        return 2048 

def convert_to_image(binary_content):
    try:
        pixel_stream = np.frombuffer(binary_content, dtype=np.uint8)

        target_width = determine_width(len(pixel_stream))
        target_height = int(np.ceil(len(pixel_stream) / target_width))

        reshaped_image = np.resize(pixel_stream, (target_height, target_width))
        img = PILImage.fromarray(reshaped_image)
        img_resized = img.resize((224, 244), PILImage.BILINEAR)

        return img_resized
    except Exception as e:
        print("An error occurred:", str(e))
        return None

# GUI functions
def upload_and_select_file():
    global file_path
    file_path = filedialog.askopenfilename(title="Select a ZIP file", filetypes=[("ZIP files", "*.zip")])
    if file_path:
        file_label.config(text=f"Selected file: {file_path}")
    else:
        file_label.config(text="No file selected!")

def search_malware(search_image):
    data_folder = ""
    # Search for nearest vectors
    pc = Pinecone(api_key='13fadf20-cd84-43e0-bda3-609c6eca3183')

    # Check if the index exists
    index_name = 'vectors-ransomwares-index'
    if index_name not in pc.list_indexes().names():
        print(f'Index {index_name} is not exists')

    api_key = '13fadf20-cd84-43e0-bda3-609c6eca3183'
     
    indexer = StoreVectors(data_folder, index_name, api_key)

    model = indexer.get_extract_model()
    search_vector = indexer.extract_vector(model,search_image)
    
    # Check if the index exists
    index_name = 'vectors-ransomwares-index-full'
    if index_name not in pc.list_indexes().names():
        print(f'Index {index_name} is not exists')

    # Query Pinecone for nearest vectors
    K = 16
    index = pc.Index(index_name)
    # Perform similarity search
    results = index.query(namespace = "ns2",vector=search_vector.tolist(), top_k=K,include_values= True)

    # Extract the matches
    matches = results['matches']  # Assuming the matches are in the first list

    # Extract the nearest image paths and distances
    nearest_image_paths = [match['id'] for match in matches]
    nearest_distances = [match['score'] for match in matches]

    # Display the nearest images
    # First Figure
    axes1 = []
    grid_size1 = int(math.sqrt(K))  # Calculate grid size based on the number of images
    fig1 = plt.figure('Ransomwares')
    # fig1.canvas.setWindowTitle('Ransomwares')
    for idx, (image_path, distance) in enumerate(zip(nearest_image_paths, nearest_distances)):
            axes1.append(fig1.add_subplot(grid_size1, grid_size1, idx + 1))
            title = f"\n Dis: {distance:.4f}"  # Extract image name and add distance
            axes1[-1].set_title(title)
            plt.imshow(PILImage.open(image_path))

    fig1.tight_layout()


    #Check if the index exists
    index_name_nonmalwares = 'vectors-nonmalwares-index-full'
    if index_name_nonmalwares not in pc.list_indexes().names():
        print(f'Index {index_name_nonmalwares} is not exists')


    # Query Pinecone for nearest vectors
    index_nonmalwares = pc.Index(index_name_nonmalwares)
    # Perform similarity search
    results_nonmalwares = index_nonmalwares.query(namespace = "ns2",vector=search_vector.tolist(), top_k=K,include_values= True)

    # Extract the matches
    matches_nonmalwares = results_nonmalwares['matches']  # Assuming the matches are in the first list

    # Extract the nearest image paths and distances
    nearest_image_paths_nonmalwares = [match['id'] for match in matches_nonmalwares]
    nearest_distances_nonmalwares = [match['score'] for match in matches_nonmalwares]

    # Second Figure
    axes2 = []
    grid_size2 = int(math.sqrt(K)) 
    fig2 = plt.figure('Non-Malwares')
    # fig2.setWindowTitle('Non-Malwares')
    for idx, (image_path, distance) in enumerate(zip(nearest_image_paths_nonmalwares, nearest_distances_nonmalwares)):
            axes2.append(fig2.add_subplot(grid_size2, grid_size2, idx + 1))
            title = f"\n Dis: {distance:.4f}"  # Extract image name and add distance
            axes2[-1].set_title(title)
            plt.imshow(PILImage.open(image_path))

    fig2.tight_layout()
    # Show both figures

    # Tính trung bình của distances
    avg_distance_ransomwares = np.mean(nearest_distances)
    avg_distance_nonmalwares = np.mean(nearest_distances_nonmalwares)

    # Hiển thị thông tin trung bình
    avg_label = f"Avg Distance - Ransomwares: {avg_distance_ransomwares:.4f}, Non-Malwares: {avg_distance_nonmalwares:.4f}"
    avg_window = tk.Toplevel(root)
    avg_window.title("Average Distances")
    avg_window.geometry("400x100")
    avg_label_widget = tk.Label(avg_window, text=avg_label)
    avg_label_widget.pack(pady=20)

    prediction_label = ""
    if avg_distance_nonmalwares > avg_distance_ransomwares:
        prediction_label = "Your file is likely non-malware."
    elif avg_distance_ransomwares > avg_distance_nonmalwares:
        prediction_label = "Your file is likely ransomware."
    else:
        prediction_label = "Unable to determine the type of file."

    avg_label_widget2 = tk.Label(avg_window, text=prediction_label)
    avg_label_widget2.pack(pady=10)
    plt.show()

def get_password():
    password = simpledialog.askstring("Password", "Enter password (if any):", show='*')
    password=password.encode() if password else None
    return password

def start_conversion():
    password = get_password()
    if file_path:
        image_file = extract_zip_to_image(file_path, password)
        if image_file:
            result_label.config(text="File extracted successfully! Wait for detect image", fg="green")
            search_malware(image_file)
    else:
        result_label.config(text="No file selected!", fg="red")

# Create the main window
root = tk.Tk() # create a Tk root window
root.title("Malware Detector")
w = 350 # width for the Tk root
h = 300 #  height for the Tk root

# get screen width and height
ws = root.winfo_screenwidth() # width of the screen
hs = root.winfo_screenheight() # height of the screen

# calculate x and y coordinates for the Tk root window
x = (ws/2) - (w/2)
y = (hs/2) - (h/2)

# set the dimensions of the screen 
# and where it is placed
root.geometry('%dx%d+%d+%d' % (w, h, x, y))
# Add widgets
file_button = tk.Button(root, text="Select ZIP File", command=upload_and_select_file)
file_button.pack(pady=20)

file_label = tk.Label(root, text="", wraplength=300)
file_label.pack(pady=10)

convert_button = tk.Button(root, text="Convert to Image", command=start_conversion)
convert_button.pack(pady=20)

result_label = tk.Label(root, text="", fg="red")
result_label.pack(pady=20)

root.mainloop()

