import os
import math
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import VGG16, preprocess_input
from tensorflow.keras.models import  Model

from PIL import Image
import numpy as np

import matplotlib.pyplot as plt

from pinecone import Pinecone, ServerlessSpec

# Get models
def get_extract_model():
    vgg16_model = VGG16(weights="imagenet")
    extract_model = Model(inputs=vgg16_model.inputs, outputs = vgg16_model.get_layer("fc1").output)
    return extract_model

# Convert Image to tensorflow
def image_preprocess(img):
    img = img.resize((224,224))
    img = img.convert("RGB")
    x = image.img_to_array(img)
    x = np.expand_dims(x,axis=0)
    x = preprocess_input(x)
    return x

def extract_vector(model, image_path):
    print("Handle: ",image_path)
    img = Image.open(image_path)
    img_tensor = image_preprocess(img)
    
    # extract feature
    vector = model.predict(img_tensor)[0]

    # Standardized vector = divided L2 norm ( from google search)
    vector = vector/np.linalg.norm(vector)
    return vector

search_image = "data_test/5d09b001c18384a9d5e8b31b9c4ee5ed77082e0a9b8783c34b3916b1534d2c21.png"
model = get_extract_model()

search_vector = extract_vector(model,search_image)

# Search for nearest vectors
pc = Pinecone(api_key='13fadf20-cd84-43e0-bda3-609c6eca3183')

# Check if the index exists
index_name = 'vectors-ransomwares-index'
if index_name not in pc.list_indexes().names():
    print(f'Index {index_name} is not exists')

# Query Pinecone for nearest vectors
K = 16
index = pc.Index(index_name)
# Perform similarity search
results = index.query(namespace = "ns2",vector=search_vector.tolist(), top_k=K,include_values= True)

# Extract the matches
matches = results['matches']  # Assuming the matches are in the first list

# Extract the nearest image paths and distances
nearest_image_paths = [match['id'] for match in matches]
nearest_distances = [match['score'] for match in matches]

# Display the nearest images
# First Figure
axes1 = []
grid_size1 = int(math.sqrt(K))  # Calculate grid size based on the number of images
# fig1 = plt.figure(figsize=(10, 10))
fig1 = plt.figure('Ransomwares')
# fig1.canvas.set_window_title('Ransomwares')
for idx, (image_path, distance) in enumerate(zip(nearest_image_paths, nearest_distances)):
        axes1.append(fig1.add_subplot(grid_size1, grid_size1, idx + 1))
        title = f"\n Dis: {distance:.4f}"  # Extract image name and add distance
        axes1[-1].set_title(title)
        plt.imshow(Image.open(image_path))

fig1.tight_layout()


#Check if the index exists
index_name_nonmalwares = 'vectors-nonmalwares-index'
if index_name_nonmalwares not in pc.list_indexes().names():
    print(f'Index {index_name_nonmalwares} is not exists')


# Query Pinecone for nearest vectors
index_nonmalwares = pc.Index(index_name_nonmalwares)
# Perform similarity search
results_nonmalwares = index_nonmalwares.query(namespace = "ns2",vector=search_vector.tolist(), top_k=K,include_values= True)

# Extract the matches
matches_nonmalwares = results_nonmalwares['matches']  # Assuming the matches are in the first list

# Extract the nearest image paths and distances
nearest_image_paths_nonmalwares = [match['id'] for match in matches_nonmalwares]
nearest_distances_nonmalwares = [match['score'] for match in matches_nonmalwares]

# Second Figure
axes2 = []
grid_size2 = int(math.sqrt(K)) 
fig2 = plt.figure('Non-Malwares')
# fig2.canvas.set_window_title('Non-Malwares')
for idx, (image_path, distance) in enumerate(zip(nearest_image_paths_nonmalwares, nearest_distances_nonmalwares)):
        axes2.append(fig2.add_subplot(grid_size2, grid_size2, idx + 1))
        title = f"\n Dis: {distance:.4f}"  # Extract image name and add distance
        axes2[-1].set_title(title)
        plt.imshow(Image.open(image_path))


fig2.tight_layout()
# Show both figures
plt.show()
